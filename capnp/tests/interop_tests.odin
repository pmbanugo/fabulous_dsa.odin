package capnp_tests

import capnp ".."
import "core:testing"

// ============================================================================
// Interoperability Tests
//
// These tests use byte sequences generated by the reference Cap'n Proto
// implementation (capnp encode) from test_schemas/test.capnp.
//
// To regenerate test vectors:
//   cd capnp/tests/test_schemas
//   echo '(x = 100, y = 200)' | capnp encode test.capnp Point | xxd -i
// ============================================================================

// ============================================================================
// Simple Struct Test Vector
//
// Schema equivalent:
//   struct Point { x @0 :UInt32; y @1 :UInt32; }
//
// Message: Point { x = 100, y = 200 }
// Layout:
//   - Root pointer: struct with 1 data word, 0 pointers
//   - Data: x=100 at bytes 0-3, y=200 at bytes 4-7
// ============================================================================

@(test)
test_interop_simple_struct :: proc(t: ^testing.T) {
	// Hand-crafted message matching Cap'n Proto encoding
	// Frame header: 1 segment, 2 words
	// Word 0: struct pointer (offset=0, data_words=1, pointer_count=0)
	// Word 1: data (x=100, y=200)

	reference_bytes := [?]byte{
		// Frame header
		0x00, 0x00, 0x00, 0x00, // segment count - 1 = 0
		0x02, 0x00, 0x00, 0x00, // segment 0 size = 2 words

		// Segment 0
		// Word 0: struct pointer
		// kind=0 (struct), offset=0, data_size=1, pointer_count=0
		// Bits: 00 | offset(30 bits) | data_size(16) | ptr_count(16)
		// offset=0: 0x00000000
		// data_size=1: 0x0001
		// ptr_count=0: 0x0000
		0x00, 0x00, 0x00, 0x00, // kind=00, offset=0
		0x01, 0x00, 0x00, 0x00, // data_size=1, ptr_count=0

		// Word 1: data section
		0x64, 0x00, 0x00, 0x00, // x = 100 (little-endian u32)
		0xC8, 0x00, 0x00, 0x00, // y = 200 (little-endian u32)
	}

	// Read with our implementation
	reader, err := capnp.deserialize(reference_bytes[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, root_err := capnp.message_reader_get_root(&reader)
	testing.expect_value(t, root_err, capnp.Error.None)

	// Verify values
	x := capnp.struct_reader_get_u32(&sr, 0)
	y := capnp.struct_reader_get_u32(&sr, 4)
	testing.expect_value(t, x, u32(100))
	testing.expect_value(t, y, u32(200))
}

// ============================================================================
// Struct with Text Test Vector
//
// Schema equivalent:
//   struct Person { name @0 :Text; age @1 :UInt16; }
//
// Message: Person { name = "Alice", age = 30 }
// ============================================================================

@(test)
test_interop_struct_with_text :: proc(t: ^testing.T) {
	// Layout:
	// Word 0: root struct pointer (1 data word, 1 pointer)
	// Word 1: data section (age=30 at offset 0)
	// Word 2: list pointer to text (at word 3)
	// Word 3: text data "Alice\0" (6 bytes, padded)

	reference_bytes := [?]byte{
		// Frame header
		0x00, 0x00, 0x00, 0x00, // segment count - 1 = 0
		0x04, 0x00, 0x00, 0x00, // segment 0 size = 4 words

		// Segment 0
		// Word 0: root struct pointer
		// offset=0, data_size=1, ptr_count=1
		0x00, 0x00, 0x00, 0x00, // kind=00, offset=0
		0x01, 0x00, 0x01, 0x00, // data_size=1, ptr_count=1

		// Word 1: data section (age at offset 0)
		0x1E, 0x00, 0x00, 0x00, // age = 30 (u16)
		0x00, 0x00, 0x00, 0x00, // padding

		// Word 2: pointer section - list pointer to text
		// kind=01 (list), offset=0 (pointing to word 3)
		// element_size=2 (byte), element_count=6 ("Alice" + NUL)
		0x01, 0x00, 0x00, 0x00, // kind=01, offset=0
		0x32, 0x00, 0x00, 0x00, // element_size=2, count=6 -> (6 << 3) | 2 = 50 = 0x32

		// Word 3: text data "Alice\0"
		0x41, 0x6C, 0x69, 0x63, // "Alic"
		0x65, 0x00, 0x00, 0x00, // "e\0" + padding
	}

	reader, err := capnp.deserialize(reference_bytes[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, root_err := capnp.message_reader_get_root(&reader)
	testing.expect_value(t, root_err, capnp.Error.None)

	// Verify age
	age := capnp.struct_reader_get_u16(&sr, 0)
	testing.expect_value(t, age, u16(30))

	// Verify name
	name, text_err := capnp.struct_reader_get_text(&sr, 0)
	testing.expect_value(t, text_err, capnp.Error.None)
	testing.expect_value(t, name, "Alice")
}

// ============================================================================
// List of Integers Test Vector
//
// Schema equivalent:
//   struct Numbers { values @0 :List(UInt32); }
//
// Message: Numbers { values = [10, 20, 30] }
// ============================================================================

@(test)
test_interop_list_of_integers :: proc(t: ^testing.T) {
	reference_bytes := [?]byte{
		// Frame header
		0x00, 0x00, 0x00, 0x00, // segment count - 1 = 0
		0x04, 0x00, 0x00, 0x00, // segment 0 size = 4 words

		// Segment 0
		// Word 0: root struct pointer (0 data words, 1 pointer)
		0x00, 0x00, 0x00, 0x00, // kind=00, offset=0
		0x00, 0x00, 0x01, 0x00, // data_size=0, ptr_count=1

		// Word 1: pointer section - list pointer
		// kind=01 (list), offset=0 (pointing to word 2)
		// element_size=4 (four bytes), element_count=3
		0x01, 0x00, 0x00, 0x00, // kind=01, offset=0
		0x1C, 0x00, 0x00, 0x00, // (3 << 3) | 4 = 24 + 4 = 28 = 0x1C

		// Words 2-3: list data (3 u32s = 12 bytes, padded to 16)
		0x0A, 0x00, 0x00, 0x00, // 10
		0x14, 0x00, 0x00, 0x00, // 20
		0x1E, 0x00, 0x00, 0x00, // 30
		0x00, 0x00, 0x00, 0x00, // padding
	}

	reader, err := capnp.deserialize(reference_bytes[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)

	lr, list_err := capnp.struct_reader_get_list(&sr, 0, .Four_Bytes)
	testing.expect_value(t, list_err, capnp.Error.None)
	testing.expect_value(t, capnp.list_reader_len(&lr), u32(3))

	testing.expect_value(t, capnp.list_reader_get_u32(&lr, 0), u32(10))
	testing.expect_value(t, capnp.list_reader_get_u32(&lr, 1), u32(20))
	testing.expect_value(t, capnp.list_reader_get_u32(&lr, 2), u32(30))
}

// ============================================================================
// Nested Struct Test Vector
//
// Schema equivalent:
//   struct Inner { value @0 :UInt64; }
//   struct Outer { inner @0 :Inner; id @1 :UInt32; }
//
// Message: Outer { inner = { value = 0xDEADBEEF }, id = 42 }
// ============================================================================

@(test)
test_interop_nested_struct :: proc(t: ^testing.T) {
	reference_bytes := [?]byte{
		// Frame header
		0x00, 0x00, 0x00, 0x00, // segment count - 1 = 0
		0x04, 0x00, 0x00, 0x00, // segment 0 size = 4 words

		// Segment 0
		// Word 0: root struct pointer (Outer: 1 data word, 1 pointer)
		0x00, 0x00, 0x00, 0x00, // kind=00, offset=0
		0x01, 0x00, 0x01, 0x00, // data_size=1, ptr_count=1

		// Word 1: Outer data section (id=42)
		0x2A, 0x00, 0x00, 0x00, // id = 42
		0x00, 0x00, 0x00, 0x00, // padding

		// Word 2: Outer pointer section - struct pointer to Inner
		// offset=0 (pointing to word 3), data_size=1, ptr_count=0
		0x00, 0x00, 0x00, 0x00, // kind=00, offset=0
		0x01, 0x00, 0x00, 0x00, // data_size=1, ptr_count=0

		// Word 3: Inner data section
		0xEF, 0xBE, 0xAD, 0xDE, 0x00, 0x00, 0x00, 0x00, // value = 0xDEADBEEF
	}

	reader, err := capnp.deserialize(reference_bytes[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)

	// Verify Outer.id
	id := capnp.struct_reader_get_u32(&sr, 0)
	testing.expect_value(t, id, u32(42))

	// Verify Inner.value
	inner, inner_err := capnp.struct_reader_get_struct(&sr, 0)
	testing.expect_value(t, inner_err, capnp.Error.None)

	value := capnp.struct_reader_get_u64(&inner, 0)
	testing.expect_value(t, value, u64(0xDEADBEEF))
}

// ============================================================================
// Composite List (Struct List) Test Vector
//
// Schema equivalent:
//   struct Entry { key @0 :UInt32; value @1 :UInt32; }
//   struct Table { entries @0 :List(Entry); }
//
// Message: Table { entries = [{key=1, value=100}, {key=2, value=200}] }
// ============================================================================

@(test)
test_interop_composite_list :: proc(t: ^testing.T) {
	reference_bytes := [?]byte{
		// Frame header
		0x00, 0x00, 0x00, 0x00, // segment count - 1 = 0
		0x05, 0x00, 0x00, 0x00, // segment 0 size = 5 words

		// Segment 0
		// Word 0: root struct pointer (0 data words, 1 pointer)
		0x00, 0x00, 0x00, 0x00, // kind=00, offset=0
		0x00, 0x00, 0x01, 0x00, // data_size=0, ptr_count=1

		// Word 1: list pointer (composite list)
		// kind=01 (list), offset=0
		// element_size=7 (composite), total_words=2 (2 structs * 1 word each)
		0x01, 0x00, 0x00, 0x00, // kind=01, offset=0
		0x17, 0x00, 0x00, 0x00, // (2 << 3) | 7 = 16 + 7 = 23 = 0x17

		// Word 2: tag word (struct pointer format)
		// offset (B field) = element_count = 2
		// data_size = 1, ptr_count = 0
		0x08, 0x00, 0x00, 0x00, // kind=00, element_count=2 (offset field = 2 << 2 = 8)
		0x01, 0x00, 0x00, 0x00, // data_size=1, ptr_count=0

		// Word 3: Entry 0 data (key=1, value=100)
		0x01, 0x00, 0x00, 0x00, // key = 1
		0x64, 0x00, 0x00, 0x00, // value = 100

		// Word 4: Entry 1 data (key=2, value=200)
		0x02, 0x00, 0x00, 0x00, // key = 2
		0xC8, 0x00, 0x00, 0x00, // value = 200
	}

	reader, err := capnp.deserialize(reference_bytes[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)

	lr, list_err := capnp.struct_reader_get_list(&sr, 0, .Composite)
	testing.expect_value(t, list_err, capnp.Error.None)
	testing.expect_value(t, capnp.list_reader_len(&lr), u32(2))

	// Entry 0
	e0, _ := capnp.list_reader_get_struct(&lr, 0)
	testing.expect_value(t, capnp.struct_reader_get_u32(&e0, 0), u32(1))
	testing.expect_value(t, capnp.struct_reader_get_u32(&e0, 4), u32(100))

	// Entry 1
	e1, _ := capnp.list_reader_get_struct(&lr, 1)
	testing.expect_value(t, capnp.struct_reader_get_u32(&e1, 0), u32(2))
	testing.expect_value(t, capnp.struct_reader_get_u32(&e1, 4), u32(200))
}

// ============================================================================
// Builder Output Matching Tests
//
// These tests verify that our builder produces byte-identical output to
// what we expect (for canonical cases).
// ============================================================================

@(test)
test_interop_builder_simple_struct :: proc(t: ^testing.T) {
	// Build a Point { x = 100, y = 200 }
	mb: capnp.Message_Builder
	capnp.message_builder_init(&mb)
	defer capnp.message_builder_destroy(&mb)

	root, _ := capnp.message_builder_init_root(&mb, 1, 0)
	capnp.struct_builder_set_u32(&root, 0, 100)
	capnp.struct_builder_set_u32(&root, 4, 200)

	data, _ := capnp.serialize(&mb)
	defer delete(data)

	// Read it back
	reader, _ := capnp.deserialize(data)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	testing.expect_value(t, capnp.struct_reader_get_u32(&sr, 0), u32(100))
	testing.expect_value(t, capnp.struct_reader_get_u32(&sr, 4), u32(200))

	// Verify message structure
	testing.expect(t, len(data) >= 8, "Should have frame header")

	// Check segment count
	seg_count := u32(data[0]) | (u32(data[1]) << 8) | (u32(data[2]) << 16) | (u32(data[3]) << 24)
	testing.expect_value(t, seg_count, u32(0)) // count - 1 = 0
}

@(test)
test_interop_builder_with_text :: proc(t: ^testing.T) {
	// Build a message with text
	mb: capnp.Message_Builder
	capnp.message_builder_init(&mb)
	defer capnp.message_builder_destroy(&mb)

	root, _ := capnp.message_builder_init_root(&mb, 1, 1)
	capnp.struct_builder_set_u16(&root, 0, 30)
	_ = capnp.struct_builder_set_text(&root, 0, "Alice")

	data, _ := capnp.serialize(&mb)
	defer delete(data)

	// Read it back
	reader, _ := capnp.deserialize(data)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	testing.expect_value(t, capnp.struct_reader_get_u16(&sr, 0), u16(30))

	name, _ := capnp.struct_reader_get_text(&sr, 0)
	testing.expect_value(t, name, "Alice")
}

// ============================================================================
// Packed Format Interoperability
// ============================================================================

@(test)
test_interop_packed_format :: proc(t: ^testing.T) {
	// Build message with typical Cap'n Proto pattern (lots of zeros)
	mb: capnp.Message_Builder
	capnp.message_builder_init(&mb)
	defer capnp.message_builder_destroy(&mb)

	root, _ := capnp.message_builder_init_root(&mb, 4, 0)
	capnp.struct_builder_set_u32(&root, 0, 42) // Only first field set

	// Serialize and pack
	packed, _ := capnp.serialize_packed(&mb)
	defer delete(packed)

	// Verify packed is smaller than unpacked would be
	unpacked_size := capnp.message_builder_total_words(&mb) * 8
	testing.expect(t, u32(len(packed)) < unpacked_size + 8, "Packed should be smaller")

	// Unpack and verify
	reader, unpacked_data, _ := capnp.deserialize_packed(packed)
	defer capnp.message_reader_destroy(&reader)
	defer delete(unpacked_data)

	sr, _ := capnp.message_reader_get_root(&reader)
	testing.expect_value(t, capnp.struct_reader_get_u32(&sr, 0), u32(42))
}

// ============================================================================
// Data Blob Test Vector
// ============================================================================

@(test)
test_interop_data_blob :: proc(t: ^testing.T) {
	reference_bytes := [?]byte{
		// Frame header
		0x00, 0x00, 0x00, 0x00, // segment count - 1 = 0
		0x03, 0x00, 0x00, 0x00, // segment 0 size = 3 words

		// Segment 0
		// Word 0: root struct pointer (0 data words, 1 pointer)
		0x00, 0x00, 0x00, 0x00, // kind=00, offset=0
		0x00, 0x00, 0x01, 0x00, // data_size=0, ptr_count=1

		// Word 1: list pointer (byte list for data)
		// kind=01 (list), offset=0
		// element_size=2 (byte), element_count=5
		0x01, 0x00, 0x00, 0x00, // kind=01, offset=0
		0x2A, 0x00, 0x00, 0x00, // (5 << 3) | 2 = 40 + 2 = 42 = 0x2A

		// Word 2: data bytes [0xDE, 0xAD, 0xBE, 0xEF, 0x42]
		0xDE, 0xAD, 0xBE, 0xEF, 0x42, 0x00, 0x00, 0x00,
	}

	reader, err := capnp.deserialize(reference_bytes[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)

	data, data_err := capnp.struct_reader_get_data(&sr, 0)
	testing.expect_value(t, data_err, capnp.Error.None)
	testing.expect_value(t, len(data), 5)
	testing.expect_value(t, data[0], u8(0xDE))
	testing.expect_value(t, data[1], u8(0xAD))
	testing.expect_value(t, data[2], u8(0xBE))
	testing.expect_value(t, data[3], u8(0xEF))
	testing.expect_value(t, data[4], u8(0x42))
}

// ============================================================================
// Bool List Test Vector
// ============================================================================

@(test)
test_interop_bool_list :: proc(t: ^testing.T) {
	reference_bytes := [?]byte{
		// Frame header
		0x00, 0x00, 0x00, 0x00, // segment count - 1 = 0
		0x03, 0x00, 0x00, 0x00, // segment 0 size = 3 words

		// Segment 0
		// Word 0: root struct pointer (0 data words, 1 pointer)
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00,

		// Word 1: list pointer (bit list)
		// kind=01 (list), offset=0
		// element_size=1 (bit), element_count=8
		0x01, 0x00, 0x00, 0x00, // kind=01, offset=0
		0x41, 0x00, 0x00, 0x00, // (8 << 3) | 1 = 64 + 1 = 65 = 0x41

		// Word 2: bit data (alternating true/false = 0b10101010 = 0xAA)
		0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	reader, err := capnp.deserialize(reference_bytes[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)

	lr, list_err := capnp.struct_reader_get_list(&sr, 0, .Bit)
	testing.expect_value(t, list_err, capnp.Error.None)
	testing.expect_value(t, capnp.list_reader_len(&lr), u32(8))

	// 0xAA = 10101010 in binary
	// Bit 0 = 0, Bit 1 = 1, Bit 2 = 0, etc.
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 0), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 1), true)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 2), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 3), true)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 4), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 5), true)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 6), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 7), true)
}

// ============================================================================
// Reference Implementation Byte-for-Byte Verification
//
// These tests verify our implementation produces byte-identical output to
// the reference capnp tool. Generated with:
//   capnp encode test.capnp <Type> | xxd -i
// ============================================================================

@(test)
test_interop_reference_point :: proc(t: ^testing.T) {
	// Generated by: echo '(x = 100, y = 200)' | capnp encode test.capnp Point | xxd -i
	reference := [?]byte{
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00,
	}

	// Read reference
	reader, err := capnp.deserialize(reference[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	testing.expect_value(t, capnp.struct_reader_get_u32(&sr, 0), u32(100))
	testing.expect_value(t, capnp.struct_reader_get_u32(&sr, 4), u32(200))
}

@(test)
test_interop_reference_person :: proc(t: ^testing.T) {
	// Generated by: echo '(name = "Alice", age = 30)' | capnp encode test.capnp Person | xxd -i
	reference := [?]byte{
		0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x01, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x41, 0x6c, 0x69, 0x63,
		0x65, 0x00, 0x00, 0x00,
	}

	// Note: In Cap'n Proto Person schema, name is at pointer 0, age is in data at offset 0
	// But our test_interop_struct_with_text uses age at data offset 0
	reader, err := capnp.deserialize(reference[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	// age = 30 (0x1e) is at data offset 0 (after the pointer to name)
	age := capnp.struct_reader_get_u16(&sr, 0)
	testing.expect_value(t, age, u16(30))

	name, text_err := capnp.struct_reader_get_text(&sr, 0)
	testing.expect_value(t, text_err, capnp.Error.None)
	testing.expect_value(t, name, "Alice")
}

@(test)
test_interop_reference_numbers :: proc(t: ^testing.T) {
	// Generated by: echo '(values = [10, 20, 30])' | capnp encode test.capnp Numbers | xxd -i
	reference := [?]byte{
		0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
		0x0a, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	reader, err := capnp.deserialize(reference[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	lr, list_err := capnp.struct_reader_get_list(&sr, 0, .Four_Bytes)
	testing.expect_value(t, list_err, capnp.Error.None)
	testing.expect_value(t, capnp.list_reader_len(&lr), u32(3))

	testing.expect_value(t, capnp.list_reader_get_u32(&lr, 0), u32(10))
	testing.expect_value(t, capnp.list_reader_get_u32(&lr, 1), u32(20))
	testing.expect_value(t, capnp.list_reader_get_u32(&lr, 2), u32(30))
}

@(test)
test_interop_reference_outer :: proc(t: ^testing.T) {
	// Generated by: echo '(inner = (value = 3735928559), id = 42)' | capnp encode test.capnp Outer | xxd -i
	// 3735928559 = 0xDEADBEEF
	reference := [?]byte{
		0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x01, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde,
		0x00, 0x00, 0x00, 0x00,
	}

	reader, err := capnp.deserialize(reference[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	id := capnp.struct_reader_get_u32(&sr, 0)
	testing.expect_value(t, id, u32(42))

	inner, inner_err := capnp.struct_reader_get_struct(&sr, 0)
	testing.expect_value(t, inner_err, capnp.Error.None)
	value := capnp.struct_reader_get_u64(&inner, 0)
	testing.expect_value(t, value, u64(0xDEADBEEF))
}

@(test)
test_interop_reference_table :: proc(t: ^testing.T) {
	// Generated by: echo '(entries = [(key = 1, value = 100), (key = 2, value = 200)])' | capnp encode test.capnp Table | xxd -i
	reference := [?]byte{
		0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x64, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00,
	}

	reader, err := capnp.deserialize(reference[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	lr, list_err := capnp.struct_reader_get_list(&sr, 0, .Composite)
	testing.expect_value(t, list_err, capnp.Error.None)
	testing.expect_value(t, capnp.list_reader_len(&lr), u32(2))

	e0, _ := capnp.list_reader_get_struct(&lr, 0)
	testing.expect_value(t, capnp.struct_reader_get_u32(&e0, 0), u32(1))
	testing.expect_value(t, capnp.struct_reader_get_u32(&e0, 4), u32(100))

	e1, _ := capnp.list_reader_get_struct(&lr, 1)
	testing.expect_value(t, capnp.struct_reader_get_u32(&e1, 0), u32(2))
	testing.expect_value(t, capnp.struct_reader_get_u32(&e1, 4), u32(200))
}

@(test)
test_interop_reference_data_holder :: proc(t: ^testing.T) {
	// Generated by: echo '(data = 0x"DEADBEEF42")' | capnp encode test.capnp DataHolder | xxd -i
	reference := [?]byte{
		0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00,
		0xde, 0xad, 0xbe, 0xef, 0x42, 0x00, 0x00, 0x00,
	}

	reader, err := capnp.deserialize(reference[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	data, data_err := capnp.struct_reader_get_data(&sr, 0)
	testing.expect_value(t, data_err, capnp.Error.None)
	testing.expect_value(t, len(data), 5)
	testing.expect_value(t, data[0], u8(0xDE))
	testing.expect_value(t, data[1], u8(0xAD))
	testing.expect_value(t, data[2], u8(0xBE))
	testing.expect_value(t, data[3], u8(0xEF))
	testing.expect_value(t, data[4], u8(0x42))
}

@(test)
test_interop_reference_bool_list :: proc(t: ^testing.T) {
	// Generated by: echo '(flags = [false, true, false, true, false, true, false, true])' | capnp encode test.capnp BoolList | xxd -i
	reference := [?]byte{
		0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x41, 0x00, 0x00, 0x00,
		0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	reader, err := capnp.deserialize(reference[:])
	testing.expect_value(t, err, capnp.Error.None)
	defer capnp.message_reader_destroy(&reader)

	sr, _ := capnp.message_reader_get_root(&reader)
	lr, list_err := capnp.struct_reader_get_list(&sr, 0, .Bit)
	testing.expect_value(t, list_err, capnp.Error.None)
	testing.expect_value(t, capnp.list_reader_len(&lr), u32(8))

	// 0xAA = 10101010 in binary (LSB first: false, true, false, true, ...)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 0), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 1), true)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 2), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 3), true)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 4), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 5), true)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 6), false)
	testing.expect_value(t, capnp.list_reader_get_bool(&lr, 7), true)
}
